# RISC-V 32E Инструкции - Спецификация

Данный документ содержит описание и спецификацию команд RISC-V 32E, поддерживаемых в miniRV CPU.

## Архитектура RV32E

- **32-битная архитектура** (RV32E - Embedded)
- **16 регистров общего назначения**: x0 - x15
- **x0 (zero register)**: всегда равен 0, записи игнорируются
- **32-битные инструкции**: фиксированная длина
- **Byte-addressable память**: байт-адресуемая память

## Форматы инструкций

RISC-V использует несколько форматов инструкций:

### R-Type (Register-Register)
```
31        25 24    20 19    15 14    12 11     7 6      0
+-----------+-------+-------+-------+-------+-----------+
|  funct7   |  rs2  |  rs1  | funct3|   rd  |  opcode   |
+-----------+-------+-------+-------+-------+-----------+
```

### I-Type (Immediate/Loads/JALR)
```
31                  20 19    15 14    12 11     7 6      0
+-------------------+-------+-------+-------+-----------+
|      imm[11:0]    |  rs1  | funct3|   rd  |  opcode   |
+-------------------+-------+-------+-------+-----------+
```

### S-Type (Store)
```
31        25 24    20 19    15 14    12 11     7 6      0
+-----------+-------+-------+-------+-------+-----------+
| imm[11:5] |  rs2  |  rs1  | funct3|imm[4:0]|  opcode  |
+-----------+-------+-------+-------+-------+-----------+
```

### U-Type (Upper Immediate)
```
31                             12 11     7 6      0
+------------------------------+-------+-----------+
|         imm[31:12]           |   rd  |  opcode   |
+------------------------------+-------+-----------+
```

---

## Инструкции

### 1. ADD (Add)

**Синтаксис:** `add rd, rs1, rs2`

**Тип:** R-Type

**Описание:** Складывает значения двух регистров и записывает результат в регистр назначения.

**Семантика:**
```
R[rd] = R[rs1] + R[rs2]
```

**Кодирование:**
- **Opcode:** `0110011` (7 бит)
- **funct3:** `000` (3 бит)
- **funct7:** `0000000` (7 бит)

**Бинарный формат:**
```
31        25 24    20 19    15 14    12 11     7 6      0
+-----------+-------+-------+-------+-------+-----------+
| 0000000   |  rs2  |  rs1  |  000  |   rd  | 0110011  |
+-----------+-------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
add x2, x1, x10
# x2 = x1 + x10
```

**Пример кодирования:**
```
add x2, x1, x10
0000000_01010_00001_000_00010_0110011
```

**Ограничения:**
- rd, rs1, rs2 должны быть в диапазоне x0-x15 (RV32E)
- Если rd = x0, инструкция выполняется, но результат не записывается

---

### 2. ADDI (Add Immediate)

**Синтаксис:** `addi rd, rs1, imm`

**Тип:** I-Type

**Описание:** Складывает значение регистра с 12-битным знаковым непосредственным значением (sign-extended).

**Семантика:**
```
R[rd] = R[rs1] + sign_extend(imm[11:0])
```

**Кодирование:**
- **Opcode:** `0010011` (7 бит)
- **funct3:** `000` (3 бит)
- **imm[11:0]:** 12-битное знаковое непосредственное значение

**Бинарный формат:**
```
31                  20 19    15 14    12 11     7 6      0
+-------------------+-------+-------+-------+-----------+
|    imm[11:0]      |  rs1  |  000  |   rd  | 0010011  |
+-------------------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
addi x3, x1, 5
# x3 = x1 + 5
```

**Пример кодирования:**
```
addi x3, x1, 5
000000000101_00001_000_00011_0010011
```

**Ограничения:**
- Диапазон immediate: -2048 до +2047 (12-битное знаковое значение)
- rd, rs1 должны быть в диапазоне x0-x15

---

### 3. LUI (Load Upper Immediate)

**Синтаксис:** `lui rd, imm`

**Тип:** U-Type

**Описание:** Загружает 20-битное верхнее непосредственное значение в старшие биты регистра, младшие 12 бит устанавливаются в 0.

**Семантика:**
```
R[rd] = imm[31:12] << 12
```

**Кодирование:**
- **Opcode:** `0110111` (7 бит)
- **imm[31:12]:** 20-битное значение (верхние 20 бит)

**Бинарный формат:**
```
31                             12 11     7 6      0
+------------------------------+-------+-----------+
|         imm[31:12]           |   rd  | 0110111   |
+------------------------------+-------+-----------+
```

**Пример:**
```assembly
lui x4, 0x12345
# x4 = 0x12345000
```

**Пример кодирования:**
```
lui x4, 0x12345
00010010001101000101_00100_0110111
```

**Примечание:**
- Используется для загрузки больших констант в регистр
- Часто используется в паре с ADDI для загрузки 32-битных значений

---

### 4. LW (Load Word)

**Синтаксис:** `lw rd, imm(rs1)`

**Тип:** I-Type

**Описание:** Загружает 32-битное слово из памяти по адресу `R[rs1] + sign_extend(imm)`.

**Семантика:**
```
R[rd] = M[R[rs1] + sign_extend(imm)][31:0]
```

**Кодирование:**
- **Opcode:** `0000011` (7 бит)
- **funct3:** `010` (3 бит)
- **imm[11:0]:** 12-битное знаковое смещение

**Бинарный формат:**
```
31                  20 19    15 14    12 11     7 6      0
+-------------------+-------+-------+-------+-----------+
|    imm[11:0]      |  rs1  |  010  |   rd  | 0000011  |
+-------------------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
lw x5, 4(x1)
# x5 = M[x1 + 4]
```

**Пример кодирования:**
```
lw x5, 4(x1)
000000000100_00001_010_00101_0000011
```

**Ограничения:**
- Адрес должен быть выровнен по границе слова (кратен 4) для оптимальной производительности
- Диапазон смещения: -2048 до +2047 байт

---

### 5. LBU (Load Byte Unsigned)

**Синтаксис:** `lbu rd, imm(rs1)`

**Тип:** I-Type

**Описание:** Загружает байт из памяти по адресу `R[rs1] + sign_extend(imm)` и расширяет его нулями до 32 бит (zero-extended).

**Семантика:**
```
R[rd] = zero_extend(M[R[rs1] + sign_extend(imm)][7:0])
```

**Кодирование:**
- **Opcode:** `0000011` (7 бит)
- **funct3:** `100` (3 бит)
- **imm[11:0]:** 12-битное знаковое смещение

**Бинарный формат:**
```
31                  20 19    15 14    12 11     7 6      0
+-------------------+-------+-------+-------+-----------+
|    imm[11:0]      |  rs1  |  100  |   rd  | 0000011  |
+-------------------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
lbu x6, 0(x1)
# x6 = zero_extend(M[x1 + 0][7:0])
```

**Пример кодирования:**
```
lbu x6, 0(x1)
000000000000_00001_100_00110_0000011
```

**Примечание:**
- Zero-extension означает, что старшие 24 бита результата устанавливаются в 0
- Полезно для работы с беззнаковыми байтами

---

### 6. SW (Store Word)

**Синтаксис:** `sw rs2, imm(rs1)`

**Тип:** S-Type

**Описание:** Сохраняет 32-битное слово из регистра `rs2` в память по адресу `R[rs1] + sign_extend(imm)`.

**Семантика:**
```
M[R[rs1] + sign_extend(imm)] = R[rs2][31:0]
```

**Кодирование:**
- **Opcode:** `0100011` (7 бит)
- **funct3:** `010` (3 бит)
- **imm[11:0]:** 12-битное знаковое смещение (разделено на imm[11:5] и imm[4:0])

**Бинарный формат:**
```
31        25 24    20 19    15 14    12 11     7 6      0
+-----------+-------+-------+-------+-------+-----------+
| imm[11:5] |  rs2  |  rs1  |  010  |imm[4:0]| 0100011  |
+-----------+-------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
sw x7, 8(x1)
# M[x1 + 8] = x7
```

**Пример кодирования:**
```
sw x7, 8(x1)
0000000_00111_00001_010_01000_0100011
```

**Ограничения:**
- Адрес должен быть выровнен по границе слова (кратен 4) для оптимальной производительности
- Диапазон смещения: -2048 до +2047 байт

---

### 7. SB (Store Byte)

**Синтаксис:** `sb rs2, imm(rs1)`

**Тип:** S-Type

**Описание:** Сохраняет младший байт (8 бит) регистра `rs2` в память по адресу `R[rs1] + sign_extend(imm)`.

**Семантика:**
```
M[R[rs1] + sign_extend(imm)][7:0] = R[rs2][7:0]
```

**Кодирование:**
- **Opcode:** `0100011` (7 бит)
- **funct3:** `000` (3 бит)
- **imm[11:0]:** 12-битное знаковое смещение (разделено на imm[11:5] и imm[4:0])

**Бинарный формат:**
```
31        25 24    20 19    15 14    12 11     7 6      0
+-----------+-------+-------+-------+-------+-----------+
| imm[11:5] |  rs2  |  rs1  |  000  |imm[4:0]| 0100011  |
+-----------+-------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
sb x8, 0(x1)
# M[x1 + 0][7:0] = x8[7:0]
```

**Пример кодирования:**
```
sb x8, 0(x1)
0000000_01000_00001_000_00000_0100011
```

**Примечание:**
- Сохраняется только младший байт регистра rs2
- Остальные байты в памяти по этому адресу не изменяются (в зависимости от реализации)

---

### 8. JALR (Jump and Link Register)

**Синтаксис:** `jalr rd, imm(rs1)`

**Тип:** I-Type

**Описание:** Безусловный переход по адресу, вычисленному как `R[rs1] + sign_extend(imm)`, с сохранением адреса возврата в регистр `rd`. Младший бит целевого адреса очищается (выравнивание по границе 2 байта).

**Семантика:**
```
temp = R[rs1] + sign_extend(imm)
R[rd] = PC + 4
PC = temp & ~1
```

**Кодирование:**
- **Opcode:** `1100111` (7 бит)
- **funct3:** `000` (3 бит)
- **imm[11:0]:** 12-битное знаковое смещение

**Бинарный формат:**
```
31                  20 19    15 14    12 11     7 6      0
+-------------------+-------+-------+-------+-----------+
|    imm[11:0]      |  rs1  |  000  |   rd  | 1100111  |
+-------------------+-------+-------+-------+-----------+
```

**Пример:**
```assembly
jalr x1, 0(x2)
# x1 = PC + 4
# PC = (x2 + 0) & ~1
```

**Пример кодирования:**
```
jalr x1, 0(x2)
000000000000_00010_000_00001_1100111
```

**Примечание:**
- Используется для вызова функций и возврата из них
- Если `rd = x0`, адрес возврата не сохраняется (просто переход)
- Младший бит целевого адреса всегда очищается (выравнивание)
- Часто используется с `imm = 0` для косвенных переходов

---

## Сводная таблица инструкций

| Инструкция | Тип  | Opcode    | funct3 | funct7    | Описание                    |
|------------|------|-----------|--------|-----------|-----------------------------|
| ADD        | R    | 0110011   | 000    | 0000000   | Сложение регистров          |
| ADDI       | I    | 0010011   | 000    | -         | Сложение с константой       |
| LUI        | U    | 0110111   | -      | -         | Загрузка верхних 20 бит     |
| LW         | I    | 0000011   | 010    | -         | Загрузка слова              |
| LBU        | I    | 0000011   | 100    | -         | Загрузка байта (zero-ext)   |
| SW         | S    | 0100011   | 010    | -         | Сохранение слова            |
| SB         | S    | 0100011   | 000    | -         | Сохранение байта            |
| JALR       | I    | 1100111   | 000    | -         | Переход с сохранением адреса|

---

## Регистры RV32E

RV32E (Embedded) использует только 16 регистров вместо стандартных 32:

| Регистр | Имя      | Описание                          |
|---------|----------|-----------------------------------|
| x0      | zero     | Всегда равен 0                    |
| x1      | ra       | Return address                    |
| x2      | sp       | Stack pointer                     |
| x3      | gp       | Global pointer                    |
| x4      | tp       | Thread pointer                    |
| x5-x7   | t0-t2    | Temporary registers               |
| x8-x9   | s0-s1    | Saved registers                   |
| x10-x11 | a0-a1    | Function arguments / return values|
| x12-x15 | a2-a5    | Function arguments                |

**Важно:** Регистры x16-x31 не существуют в RV32E и использование их в инструкциях приведет к неопределенному поведению или будет обработано как недопустимая инструкция.

---

## Примечания по реализации

1. **Выравнивание памяти:**
   - Слова (LW/SW) должны быть выровнены по границе 4 байта для оптимальной производительности
   - Байты (LBU/SB) могут быть по любому адресу

2. **Знаковое расширение:**
   - I-type и S-type immediate значения расширяются знаковым образом (sign-extend)
   - LBU использует zero-extension для загруженного байта

3. **Регистр x0:**
   - Всегда возвращает 0 при чтении
   - Запись в x0 игнорируется (но инструкция выполняется)

4. **JALR выравнивание:**
   - Младший бит целевого адреса всегда очищается: `PC = (rs1 + imm) & ~1`
   - Это обеспечивает выравнивание по границе 2 байта

---

## Ссылки

- [RISC-V Unprivileged ISA Specification](https://riscv.org/technical/specifications/)
- [RISC-V 32E Base Integer Instruction Set](documentation/unpriv-isa-asciidoc.pdf)

